require 'test_helper'

class ButtonApplicationHelperTest < SharedApplicationHelperTest
# %%vi%%he%%app%%but

  test "happy path should render..." do
# A ?, once:
##    assert_select CssString.new('div').css_class('button  ? '), 1
  end

#-------------
  private

  def setup
##    button(bt,c,a,co,m=:get)
  end

end
require 'test_helper'

class AllTagsPicturesHelperTest < SharedPicturesHelperTest
# %%vi%%he%%pic%%atgs

  test "happy path should render..." do
# The right partial, once:
    assert_partial 'pictures/_all_tags', 1
# A list of all tags:
    assert_select CssString.new('div').css_class('all-tags'), 1
  end

#-------------
  private

  def setup
    c=:pictures
    @controller.default_url_options={:controller=>c}
    render_all_tags
  end

end
require 'test_helper'

class GalleryPicturesHelperTest < SharedPicturesHelperTest
# %%vi%%he%%pic%%gal %%pic%%pic

  test "happy path should render..." do
# The right partial, once:
    assert_partial 'pictures/_gallery', 1
# A gallery, once:
    assert_select CssString.new('div').css_class('gallery'), 1
  end

#-------------
  private

  def setup
    gallery
  end

end
require 'test_helper'

class AllLayoutTest < SharedLayoutTest
# %%vi%%lay%%all

  test "layouts..." do
    layouts do
# Partials should render...:
# A list of all tags, once:
      assert_partial 'pictures/_all_tags', 1
# The session buttons, messages, scripts, and styles, once:
      %w[buttons messages scripts styles].each{|e|
          assert_partial 'application/_'+e, 1}
#-------------
# Pretty html source:
      check_pretty_html_source( %w[
      Action\ content  All\ tags  Messages  Scripts  Session\ buttons  Styles
          ], %w[
      action-content  admin-pictures-index  all-tags  destroy  edit  messages
      scripts  session-buttons  show  user-pictures-index 
          ], %w[
      /body></html  !DOCTYPE\ html  /head></body  html><head  script
      script\ src="/javascripts/  style  /style  title
          ])
#-------------
# Html should...
# Have the right document type:
      assert_doctype
# Include one html tag:
      assert_select @ht, 1
# Html tag should include...
# One head, first:
      assert_descend @ht, @h
      assert_select @ht.first(@h), 1
# One body, last:
      assert_descend @ht, @b
      assert_select @ht.last(@b), 1
#-------------
# Html head section should include...
# One title, first:
      assert_descend @h, @t
      assert_select @h.first(@t), 1
# One scripts div, after the title:
      assert_select @ds, 1
      assert_select @h.descend(@t.adjacent @ds), 1
# One style tag, last:
      assert_select @s, 1
      assert_select @h.last(@s), 1
#-------------
# Html body section should include...
# One messages div:
      assert_descend @b, @dm
# One all-tags div:
      assert_descend @b, @dat
# One action content div:
      assert_descend @b, @dac
# One session-buttons div, whether or not manage-session buttons are suppressed:
      assert_descend @b, @dsb
    end
    setup :@suppress_buttons => true
    layouts do
      assert_descend @b, @dsb
    end
  end

#-------------
  private

  def assert_descend(a,b)
    assert_select b, 1
    assert_select a.descend(b), 1
  end

  def assert_doctype
    s="<!DOCTYPE html>\n"
    assert rendered.start_with?(s), s
  end

  def layouts
    @filenames.each do |f|
      setup_with_controller if @need_reload
      @need_reload=true
      render_layout f, *@instance_variables
      yield
    end
  end

  def setup(*args)
    @instance_variables=args
    @need_reload=false unless args
    begin
      @filenames=[]
      App.root.join('app/views/layouts').find do |path|
        b=path.basename.to_s
        Find.prune if path.directory? && ?.==b[0]
        @filenames << path.dirname.join(b.chomp '.html.erb') if path.file?
      end
    end unless @filenames
    @b,@h,@ht,@s,@t = %w[body head html style title].map{|e| CssString.new e}
    d=CssString.new 'div'
    @ds,@dm,@dsb,@dat,@dac = %w[
    scripts  messages  session-buttons  all-tags  action-content
        ].map{|e| d.css_class e}
  end

end
require 'test_helper'

class ButtonsApplicationPartialTest < SharedPartialTest
# %%vi%%part%%app%%but

  helper ApplicationHelper

  test "should obey the suppress buttons flag" do
    assert_select @dd, 5
    setup{@suppress_buttons=true}
    assert_select @dd, false
  end

  test "happy path should render..." do
# Pretty html source:
    labels,functions = %w[\ pictures  -pictures-index].map{|p|
        %w[admin  user].map{|e| e+p }}
    labels    += %w[  files  database\ problems  log\ out ]
    functions += %w[  edit   show                destroy  ]
    check_pretty_html_source 'Session buttons', functions + [@sb]
# The right partial, once:
    assert_partial
# A single session-buttons div:
    assert_select @ds, 1
# Various button divs:
    assert_select @ds.child(@d), 5
# Various button forms:
    assert_select @f, 5
    assert_select (fb=(@f.css_class 'button_to')), 5
# Most buttons open in the same tab...:
    assert_select fb.not(CssString.new.attribute 'target'), 4
# Except 'user pictures', which opens a new window:
    assert_single [(@d.css_class('user-pictures-index').child @f),'target'],
        '_blank'
# Most use http method, GET...:
    assert_select fb.attribute('method','get'), 4
# Except 'log out', which uses method, POST:
    assert_single [(@d.css_class('destroy').child @f),'method'], 'post', false
    url_options=[
        {:controller => :admin_pictures, :action => :index   },
        {:controller => :pictures,       :action => :index   },
        {:controller => :sessions,       :action => :edit    },
        {:controller => :sessions,       :action => :show    },
        {:controller => :sessions,       :action => :destroy },
        ]
# Various buttons, which should...:
    functions.zip(labels,url_options).each do |f,v,u|
# Be single in their class:
      assert_select (s=(@d.css_class f)), 1, f
# Have the right class:
      assert_select s.child(fb), 1, f
# Be submit buttons:
      sn=s.descend(@i).not CssString.new.attribute 'name'
      assert_single [sn,'type' ], 'submit', false
# Show the right text on their face:
      assert_single [sn,'value'], v,        false
# Link to the right URL:
      assert_single [(s.child @f),'action'], (url_for u), false
    end
  end

#-------------
  private

  def setup(&block)
    controller_yield &block
    render_partial 'application/buttons'
    @d,@f,@i = %w[div form input].map{|e| CssString.new e}
    @sb='session-buttons'
    @ds=@d.css_class @sb
    @dd=@ds.descend @d
  end

end
require 'test_helper'

class MessagesApplicationPartialTest < SharedPartialTest
# %%vi%%part%%app%%mes

  test "happy path should render..." do
# Pretty html source:
    check_pretty_html_source 'Messages', %w[messages  notice  notice\ error]
# The right partial, once:
    assert_partial
# And...
# Include one messages div with the right contents:
    assert_single CssString.new('div').css_class('messages'), @text
  end

#-------------
  private

  def setup
    @text=[:notice,:error].map{|e| s="some #{e}"; flash.now[e]=s}.join "\n"
    render_partial 'application/messages'
  end

end
require 'test_helper'

class ScriptsApplicationPartialTest < SharedPartialTest
# %%vi%%part%%app%%scr

  test "scripts div..." do
# Should include certain script tags in order:
    assert_select @dss, 6

## filename_matcher
## gallery_directory
## gallery_uri

    %w[ prototype effects dragdrop controls rails application].
        each_with_index do |e,i|
      r=static_asset_matcher base_uri.join *['javascripts',"#{e}.js"]
      assert_single [@ds + " :nth-child(#{i+1})", 'src'], r, false
    end
  end

  test "happy path should render..." do
# Pretty html source:
    check_pretty_html_source 'Scripts', 'scripts', 'script'
# The right partial, once:
    assert_partial
# And...
# Include one scripts div which should include six...:
    assert_select @ds, 1 do
# Tags:
      assert_select @ds.descend('*'), 6
# Script tags:
      assert_select @dss, 6
      assert_select @dss.attribute('type','text/javascript'), 6
    end
# Only those script tags:
    assert_select @ds, ''
    assert_select @ds.descend('*').not('script'), false
  end

#-------------
  private

  def setup
    render_partial 'application/scripts'
    @d=CssString.new 'div'
    @ds=@d.css_class 'scripts'
    @dss=@ds.descend 'script'
  end

end
require 'test_helper'

class StylesApplicationPartialTest < SharedPartialTest
# %%vi%%part%%app%%sty

  test "happy path should render..." do
# Pretty html source:
    check_pretty_html_source @s.pluralize.capitalize, nil, [@s,'/'+@s]

# The right partial, once:
    assert_partial
# A styling suggestion for a list of all tags:
    include? @d.css_class('tags').child @d.css_class('tag')

# A gallery styling suggestion:
##    include? @dp.descend @dib
    include? @dp
# And...
# Shouldn't display a picture commit button:
    s = @dp.child(CssString.new('form').css_class('edit_picture'),'input').
        attribute('name', 'commit').descend "\n" + (display 'none')
    s = s.gsub " \n", "\n"
    include? s
# Session buttons should be horizontal:
    s = @d.css_class('session-buttons').child(@d,'form').css_class('button_to').
        child(@d).descend "\n" + @di
    s = s.gsub " \n", "\n"
    include? s
# Labels should be horizontal:
    s = @d.css_class('label').descend "\n" + @dib
    s = s.gsub " \n", "\n"
    include? s
# Include one style tag:
    assert_single [@s,'class'], @s+'s'
    assert_single [@s,'type' ], 'text/css'
  end

#-------------
  private

  def assert_select_include?(css, string)
    assert_select css, (Regexp.new Regexp.escape string)
  end

  def display(s)
    CssString.new '{display: ' + s + '}'
  end

  def setup
    render_partial 'application/styles'
    @d,@s = %w[div style].map{|e| CssString.new e}
    @di,@dib = %w[inline inline-block].map{|e| display e}
    @dp=@d.css_class 'picture'
  end

  def include?(substring)
    assert_select_include? @s.attribute('type','text/css'), substring
  end

end
require 'test_helper'

class AllTagsPicturesPartialTest < SharedPartialTest
# %%vi%%part%%pic%%atgs

  test "happy path should render..." do
# Pretty html source:
    check_pretty_html_source 'All tags', 'all-tags'
# The right partial, once:
    assert_partial
# One all-tags div:
    s=CssString.new 'div.all-tags'
    assert_select s, 1
# A single tag list:
    assert_select s.child('div.tags'), 1
  end

#-------------
  private

  def setup
    c=:pictures
    @controller.default_url_options={:controller=>c}
    @all_tags=Tag.all
    render_partial 'pictures/all_tags'
  end

end
require 'test_helper'

class FieldPicturesPartialTest < SharedPartialTest
# %%vi%%part%%pic%%fie

  test "happy path should render..." do
# Pretty html source:
    check_pretty_html_source nil, 'field'
# The right partial, once:
    assert_partial
# One field div:
    assert_select @df, 1
# Div for field:
    assert_select @dt, 1
# A model attribute:
    assert_single @df.child(@dt), @field
  end

  test "whether show_filename..." do
    f='filename'
    s=@fd.css_class f
    assert_select s, false
    setup(f){@show_filename=true}
# Should render a single, right filename:
    assert_single s, @field
# Without input:
    assert_select s.child('input'), false
  end

  test "whether edit_allowed..." do
    not_test = %w[ filename ]
    automatic = %w[ id ] + %w[ cre  upd ].map{|e| e+'ated_at'}
    attributes=Picture.column_names
    (attributes-automatic-not_test).sort.each do |f|
      s=@fd.css_class f
      reset_flags f
      if %w[ sequence weight ].include? f
        assert_single s, ''
      else
# Should render a single, right value:
        assert_single s, @field
      end
      setup(f){@edit_allowed=true}
# Should render a single, right value:
      assert_single s, @field
    end
  end

  test "whether show_labels..." do
    automatic = %w[ id ] + %w[ cre  upd ].map{|e| e+'ated_at'}
    attributes=Picture.column_names
    (attributes-automatic).sort.each do |f|
      value="&nbsp; #{f}"
      s=@d.css_class(f).child(@d).css_class 'label'
      reset_flags f
      if %w[ title year ].include? f
# Should render a single, right label:
        assert_single s, value
      else
        assert_select s, false
      end
      setup(f){@show_labels=true}
      if %w[ filename sequence weight].include? f
        assert_select s, false
      else
# Should render a single, right label:
        assert_single s, value
      end
      setup(f){@show_filename=@show_labels=true}
      if %w[ sequence weight].include? f
        assert_select s, false
      else
# Should render a single, right label:
        assert_single s, value
      end
# In all these circumstances...:
# Should render a single, right label:
      setup(f){@edit_allowed=@show_labels=true}
      assert_single s, value
      setup(f){@editing=@show_labels=true}
      assert_single s, value
      setup(f){@edit_allowed=@editing=@show_labels=true}
      assert_single s, value
    end
  end

  test "whether editing..." do
    not_test = %w[ filename ]
    automatic = %w[ id ] + %w[ cre  upd ].map{|e| e+'ated_at'}
    attributes=Picture.column_names
    (attributes-automatic-not_test).sort.each do |f|
      s=@fd.css_class f
      reset_flags f
      si=s.child 'input'
      assert_select si, false
      if %w[ sequence weight ].include? f
        assert_single s, ''
      else
# Should render a single, right value:
        assert_single s, @field
      end
      setup(f){@editing=true}
      if %w[ sequence ].include? f
# Should render a single, right value:
        assert_single s, @field
        assert_select si, false
      else
        assert_single s, '' 
        assert_single si, ''
# Should render a single, right value in an editing box:
        assert_single [si,'name'], "picture[#{f}]"
        assert_single [si,'type'], 'text'
        assert_single [si,'value'], @field
      end
    end
  end

#-------------
  private

  def reset_flags(field)
    setup(field){@edit_allowed=@editing=@show_filename=nil}
  end

  def setup(field='title',&block)
# Naming this method, 'render', then using 'super', failed somehow.
    controller_yield &block
    c=:pictures
    @controller.default_url_options={:controller=>c}
    record=Picture.new
    record[field]=(@field="some #{field} value")
    render_partial 'pictures/field', :record => record, :field => field.to_sym
    @d=CssString.new 'div'
    @df,@dt = %w[ field title ].map{|e| @d.css_class e}
    @fd=@df.child @d
  end

end
require 'test_helper'

class GalleryPicturesPartialTest < SharedPartialTest
# %%vi%%part%%pic%%gal %%pic%%pic

  helper PicturesHelper

  test "happy path should render..." do
# Pretty html source:
    check_pretty_html_source 'Pictures',
        %w[ field  gallery  picture  thumbnail ], 'form'
# The right partial, once:
    assert_partial
# One gallery div:
    assert_select @dg, 1
# All the pictures within the gallery:
    assert_select @dg.child('div').css_class('picture'), 2
  end

#-------------
  private

  def setup
    c=:pictures
    @controller.default_url_options={:controller=>c}
    @pictures=Picture.all
    render_partial 'pictures/gallery'
    @dg=CssString.new('div').css_class 'gallery'
  end

end
require 'test_helper'

class PicturePicturesPartialTest < SharedPartialTest
# %%vi%%part%%pic%%pic

# TODO: possibly use http://github.com/justinfrench/formtastic

  test "happy path should render..." do
# The right partial, once:
    assert_partial
# A single, right picture:
    assert_single [@dp,'id'], 'picture_'+@picture.id.to_s
# With...:
# Single divs for...:
# Complex picture parts:
    complex = %w[ tags thumbnail ]
    complex.each{|e| assert_select @pd.css_class(e), 1}
# Non-automatic attributes:
    automatic = %w[ id ] + %w[ cre  upd ].map{|e| e+'ated_at'}
    attributes=@picture.attributes.keys
    (attributes-automatic).each{|e| assert_select @fi.css_class(e), 1}
# And...:
# The right tags:
    assert_select @pd.css_class('tags'), (@picture.tags.map(&:name).join "\n")
# The right thumbnail:

## base_uri
## filename_matcher
## gallery_directory

    assert_single [@pd.css_class('thumbnail').child('a'),'href'], gallery_uri.
        join(@picture.filename), false
# With the thumbnail partial:
    assert_template :partial => 'pictures/_thumbnail', :count => @render_count
# Regarding edit_allowed...:
# If it is not...:
    reset_flags
# No edit div:
    @de=@dp.child(@d).css_class 'edit'
    @fb=@de.child(@f).css_class 'button_to'
    assert_select @de, false
    assert_select @fb, false
# If it is...:
    setup{@edit_allowed=true} # Switch.
# A single edit div...:
    assert_select @de, 1
# Containing a single button...:
# With method, GET:
    assert_single [@fb,@m], 'get'
# And...:
# Regarding editing...:
# If we are not...:
    reset_flags
# No editing form:
    @df=@dp.child @f
    assert_select @df, false
# Tags are rendered with the partial for...:
# Tags:
    assert_template :partial => 'pictures/_tags', :count => @render_count
# Not a field:
    field_count=(attributes-automatic).length
# Rails bug (testing partial locals): see test/unit/views/_test.rb.
    assert_template :partial => 'pictures/_field', :count =>
        @render_count*field_count
# If we are...:
    setup{@editing=true} # Switch.
# A single editing form, with...:
    assert_select @df, 1
# A single, submit-type input:
    @di=@df.child 'input'
    assert_single [@di,'type'], :submit, false
    assert_single [@di,'name'], :commit, false
    assert_single [@di,'value'], 'Save changes', false
# A single, right...:
# Action url:
    assert_single [@df,'action'], (url_for :controller => :admin_pictures,
        :action => :show, :id => @picture.id)
# Http method:
    assert_single [@df,@m], :post
# Tags are rendered with the partial for...:
# A field:
    assert_template :partial => 'pictures/_field', :count =>
        @render_count*field_count + 1
# Not tags:
    assert_template :partial => 'pictures/_tags', :count => @render_count - 1
# And...:
# Pretty html source:
## The @link_controller flag makes no difference.
    setup{@edit_allowed=@editing=@show_filename=true}
    check_pretty_html_source nil, %w[ edit field picture thumbnail ],
        'form accept'
  end

#-------------
  private

  def reset_flags
    setup{@edit_allowed=@editing=@show_filename=nil}
  end

  def setup(&block)
    @render_count ||= 0; @render_count += 1
    @controller.default_url_options={:controller=>:pictures}
    p=@picture=(pictures :two)
    %w[sequence weight].each{|e| p[e]='two-'+e}
    controller_yield &block
    render_partial 'pictures/picture', :picture => p
    @m='method'
    @d,@f = %w[div form].map{|e| CssString.new e}
    @dp=@d.css_class 'picture'
    @pd=@dp.child @d
    @fi=@pd.css_class('field').child @d
  end

end
require 'test_helper'

class TagsPicturesPartialTest < SharedPartialTest
# %%vi%%part%%pic%%tgs %%pic%%tag

  test "should render the right tag name" do
    tag_two
    assert_single @ds, 'two-name'
  end

  test "happy path should render..." do
    render_all_tags
# Pretty html source:
    check_pretty_html_source nil, %w[tags  tag]
# The right partial, once:
    assert_partial
# The tag partial, the right number of times:
    assert_partial 'pictures/_tag', 3
# A single all-tags div:
    assert_select @dt, 1 do
# At least one tag within a list of all tags:
      assert_select @ds
    end
  end

#-------------
  private

  def render_all_tags
    @tags=Tag.all
    render_partial
  end

  def render_partial
    c=:pictures
    @controller.default_url_options={:controller=>c}
    super 'pictures/tags', :tags => @tags
  end

  def setup
    @d=CssString.new 'div'
    @dt=@d.css_class 'tags'
    @ds=@dt.child(@d).css_class 'tag'
  end

  def tag_two
# Didn't seem to invoke the ActiveRecord test method, tags:
# ArgumentError: wrong number of arguments (1 for 0):
##       tags(:one).destroy
    @tags=Tag.where :name => 'two-name'
    render_partial
  end

end
require 'test_helper'

class TagPicturesPartialTest < SharedPartialTest
# %%vi%%part%%pic%%tag

  test "happy path should render..." do
    happy_path
# The right partial, once:
    assert_partial
# Pretty html source:
    check_pretty_html_source nil, 'tag'
# A single...:
# Tag div, which should have the right css id:
    assert_single [@dt,'id'], "tag_#{@tag.id}"
# Anchor, which should link to the right tag:
    assert_single [(@dt.child 'a'),'href'], (@controller_uri.join @tag.name)
  end

  test "if tag is not a model record" do
    render_tag 'some-tag'
  end

#-------------
  private

  def happy_path
    render_tag tags :two
  end

  def setup
    c=:pictures
    @controller.default_url_options={:controller=>c}

## filename_matcher
## gallery_directory
## gallery_uri

    @controller_uri=base_uri.join c.to_s
    @d=CssString.new 'div'
    @dt=@d.css_class 'tag'
  end

  def render_tag(t)
    @tag=t
    render_partial 'pictures/tag', :tag => @tag
  end

end
require 'test_helper'

class ThumbnailPicturesPartialTest < SharedPartialTest
# %%vi%%part%%pic%%th

  test "happy path should render..." do
# Pretty html source:
    check_pretty_html_source nil, 'thumbnail'
# The right partial, once:
    assert_partial
# A single...:
# Thumbnail div:
    assert_select @dt, 1
# Anchor, which should...:
    assert_select @dt.child(@a), 1
# Link to the right picture:

## base_uri
## gallery_directory
## gallery_uri

    assert_single [@a,'href'], (filename_matcher 'two.png')
# Open in a new window:
    assert_single [@a,'target'], '_blank'
# And...:
# A single...:
# Image, which should have the right...
    assert_select @dt.child(@a,@i), 1
# Thumbnail filename source:
    assert_single [@i,'src'], (filename_matcher 'two-t.png')
# Title as alt-text:
    assert_single [@i,'alt'], 'two-title'
  end

#-------------
  private

  def setup
    c=:pictures
    @controller.default_url_options={:controller=>c}
    picture=pictures :two
    touch_picture_files [nil,'-t'].map{|e| "two#{e}.png"}
    render_partial 'pictures/thumbnail', :picture => picture
    @a,@i = %w[a img]
    @d=CssString.new 'div'
    @dt=@d.css_class 'thumbnail'
  end

  def teardown
    delete_picture_files
  end

end
require 'test_helper'

class ApprovalGroupSessionsPartialTest < SharedPartialTest
# %%vi%%part%%ses%%ag

  test "happy path should render..." do
# The right partial, once:
    assert_partial
# A single...:
# Approval div:
    assert_select @da, 1, @da
# Submit button:
    assert_select @is, 1, @b
# Form...:
    assert_select @da.child(@f), 1, @f
# Which is an approval form...:

## filename_matcher
## gallery_directory
## gallery_uri

    assert_single [@f,'action'], (base_uri.join 'session')
    assert_single [@f,@m], 'post'
# Which should...:
# Indicate the http method, PUT:
    assert_single [@f.child(@d,@ih).attribute('name', '_'+@m), @v], 'put', false
# Include a submit button...:
# On which should be the appropriate text:
    assert_single [(@f.child @is), @v], @group.message, false
# Containing the appropriate approval group:
    assert_single [(@f.child @ih), @v], @group.list, false
# Include a hidden input...:
    %w[name id].each{|e| assert_single [(@f.child @ih), e], @a+'_group', false}
  end

#-------------
  private

  def setup
    c=:sessions
    @controller.default_url_options={:controller=>c}
    @group=Struct.new(:list,:message).new 'some-list', 'some-message'
    render_partial 'sessions/approval_group', :approval_group => @group
    @a,@b,@d,@f,@i,@m,@v = %w[
        approval  button  div  form  input  method  value
        ].map{|e| CssString.new e}
    @ih,@is = %w[hidden  submit].map{|e| @i.attribute 'type', e}
    @da=@d.css_class 'approve'
  end

end
require 'test_helper'

class ReviewGroupSessionsPartialTest < SharedPartialTest
# %%vi%%part%%ses%%rg

  test "happy path should render the right..." do
    happy_path
# Partial, once:
    assert_partial
# Div class:
    assert_select @dg, 1
# Which should contain the right...:
# Message, once:
    assert_select @gm, 1
    assert_single @dm, @group.message
# List, once:
    assert_select @gl, 1
# Which should contain the right...:
# Number of pictures:
    assert_select @ga, 2
    assert_select @da, 2
    assert_select @a, 2
# Picture filenames, each once:
# And only the pictures:
    assert_select (@dl.descend '*'), 4
    assert_select (@dl.child 'a'), 2
    assert_select (@dl.child(@d).css_class 'picture-errors'), 2
    assert_single @dl, (@group.list.map(&:filename).map{|e| e+'.'}.join "\n")
  end

  test "if list is not of a model" do
    render_partial
# Should render the list itself:
    assert_single @gl, (@group.list.join ' ')
  end

  test "if list is empty" do
    @group.list=[]
    render_partial
# Should render a special list value:
    assert_single @gl, @special
  end

  test "if message is empty" do
    @group.message=''
    render_partial
# Should render the empty message:
    assert_single @gm, ''
  end

  test "if both list and message are empty, should render..." do
    @group.list, @group.message = [], ''
    render_partial
# A special list value:
    assert_single @gl, @special
# The empty message:
    assert_single @gm, ''
  end

#-------------
  private

  def happy_path
    @group.list=Picture.all
    render_partial
  end

  def render_partial
    super 'sessions/review_group', :review_group => @group
  end

  def setup
    c=:sessions
    @controller.default_url_options={:controller=>c}
    @group=Struct.new(:list,:message).new  %w[abc def], 'something'
    @special='(none)'
    @a,@d = %w[a div].map{|e| CssString.new e}
    @dg,@dl,@dm = %w[group  list  message].map{|e| @d.css_class 'review-'+e}
    @gl,@gm=[@dl,@dm].map{|e| @dg.child e}
    @da,@ga=[@dl,@gl].map{|e| e.child @a}
  end

end
class SharedViewTest < ActionView::TestCase
# %%vi

  private

  def assert_partial(*args)
    p=c=nil
    [args].flatten.each do |e|
      p=e if e.kind_of? String
      c=e if e.kind_of? Integer
    end
    p=@partial if p.blank?
    c=1 if c.blank?
    # ActionController::TemplateAssertions:
    assert_template :partial => p, :count => c
  end

  def assert_single(selector,value,also_attribute_alone=true)
    if (was_array=selector.kind_of? Array)
      raise unless 2==selector.length
      s,a=*selector
    else
      s=selector
    end
    s||=''
    s=CssString.new(s) unless s.kind_of? CssString
    unless was_array
      assert_select s, 1, s+' count'
      assert_select s, value
    else
      assert_select s, 1 unless s.blank?
      (! also_attribute_alone ? [s] : [s, CssString.new]).each do |e|
        assert_select e.attribute(a), 1
        assert_select e.attribute(a,'?'), value
      end
    end
  end

  def base_uri
    Pathname '/webmas-gallery'
  end

  def check_pretty_html_source(*args)
# TODO: remove array, 'type' (just show types in a comment, above). Use undef?
    type   = %w[  section  div            tag  other  ]
    prefix = %w[  <!--     <div\ class="  <           ]
    suffix = %w[  -->      "                          ]
    args.map!{|e| e=[] if e.blank?; e=[e] unless e.kind_of? Array; e}
    args=Array.new(type.length,[]).fill(nil,args.length){|i| args.at i}
# print args.inspect
    source=try(:rendered) || response.body
    big=Regexp.union( (0...args.length).map{|i|
        Regexp.new "#{prefix.at i}#{Regexp.union args.at i}#{suffix.at i}"} )
    line_start=Regexp.new %r"^#{big}"
    nl="\n"
# So far, the application has not required repeating this substitution:
    altered=source.gsub line_start, nl
    s=altered.clone.gsub! big, ''
    return if s.blank?
    anywhere_in_line=s.split nl
    a= altered.split nl
    flunk (0...a.length).reject{|i| a.at(i)==(anywhere_in_line.at i)}.map{|i|
        [(a.at i), (anywhere_in_line.at i), '']}.flatten.join nl
  end

  def delete_picture_files
    @picture_files.each{|e| e.delete}
  end

## gallery_uri
  def filename_matcher(s)
# Keep: may be needed when in sub-URI.
##    prefix='webmas-gallery'
##    Pathname('/').join *[prefix,'images','gallery']
    static_asset_matcher Pathname('images').join *['gallery',s]
  end

  def static_asset_matcher(s)
# TODO def static_asset_matcher(s) # Lost the digits; don't know why.
    e=Regexp.escape base_uri.join s
    Regexp.new %r"\A#{e}\d*\z"
  end

  def touch_picture_files(filenames)
    d=DirectoryPicture.gallery_directory
    p=@picture_files=filenames.map{|e| d.join e}
    p.each{|e| FileUtils.touch e}
  end

  class CssString < String
    def adjacent( *a) CssString.new a.unshift(self).join ' + ' end
    def child(    *a) CssString.new a.unshift(self).join ' > ' end
    def css_class(*a) CssString.new a.unshift(self).join  '.'  end
    def css_id(   *a) CssString.new a.unshift(self).join  '#'  end
    def descend(  *a) CssString.new a.unshift(self).join  ' '  end

    def first(*a) self.child(*a) + ':first-child' end
    def last( *a) self.child(*a) +  ':last-child' end

    def not(*a)  s=':not('; self + s + a.join( ')'+s) + ')' end
    def +(value) CssString.new [self,value].to_s end

    def attribute(*a)
      odd_p=pairs=(a.length+1)/2
      odd_p -= a.length%2
      r=self.clone
      pairs.times do |i|
        r << '[' + a.shift
        r << '=' + a.shift if i < odd_p
        r << ']'
      end
      CssString.new r
    end

  end

end
require 'test_helper'

class SingleAdminPicturesTemplateTest < SharedViewTest
# %%vi%%temp%%adm%%si

  test "happy path should render..." do
# TODO: Pretty html source:
#    check_pretty_html_source
# The right template:
    assert_template @template
# A single picture:
    assert_partial 'pictures/_picture', 1
# The right picture:
    assert_single [(CssString.new('div').css_class 'picture'),'id'],
        'picture_'+@picture.id.to_s
  end

#-------------
  private

  def setup
    if @template.blank?
      @link_controller=:admin_pictures
      @picture=pictures :two
      @template='admin_pictures/single'
      render :template => @template
    end
  end

end
require 'test_helper'

class NewSessionsTemplateTest < SharedViewTest
# %%vi%%temp%%ses%%new

  test "happy path should render..." do
# Pretty html source:
    check_pretty_html_source nil, nil, %w[form  input\ id="password  p]
# The right template:
    assert_template @template
# One password form with method post:
    s=CssString.new 'form'
    assert_single [(s.css_class 'password'),'method'], 'post'
# One form with password field:
    assert_select s.child('input').css_id('password'), 1
# And...:
# Should prompt for password:
    assert_single 'p', %q@Type the password and hit 'Enter'.@
  end

#-------------
  private

  def setup
    render :template => (@template='sessions/new') if @template.blank?
  end

end
